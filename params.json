{"name":"Just","tagline":"Just another MVC Framework","body":"![Just](https://raw.githubusercontent.com/jsz1/just/master/just.png)\r\n\r\nJust is a fast, small, thoughtfully written javascript MVC Framework. It's has 3 main goals.\r\n  \r\n  - To be everything you need.\r\n  - To solve common problems and pitfalls that large and small apps have.\r\n  - To be easy to write.\r\n\r\n## Documentation\r\n\r\n- [J](#j)\r\n- [J.extends`](#jextends)\r\n- [\"Static\" Methods](#static-methods)\r\n- [The Blueprint](#the-blueprint)\r\n- [Getting and Setting properties](#getting-and-setting-properties)\r\n- [super](#_super)\r\n- [The Mapper](#the-mapper)\r\n- [Data Binding](#data-binding)\r\n- [Templating Engine](#templating-engine)\r\n- [Views](#views)\r\n- [Models](#models)\r\n- [Events](#events)\r\n- [App](#app)\r\n\r\n# Just\r\nJust has **0** dependecies. IE >= 9 is supported.\r\n\r\n### J\r\n* Main `J` Object which contains static methods.\r\n\r\n### J.extends`\r\n\r\n* Create inheritance easily: \r\n `J.extends(Superclass, Class def (optional))`\r\n Example:\r\n \r\n```javascript\r\nvar TinyModel = J.extends(MiniModel, {\r\n\tbump : function() {\r\n\t\tconsole.log(\"bumpping\")\r\n\t}, \r\n\r\n\tinit : function() {\r\n\t\tconsole.log(\"initting Tiny Model\")\r\n\t}\r\n});\r\n\r\n```\r\nYou can read this as `TinyModel` will extend or inherit from `MiniModel`.\r\n\r\nWhen creating a class definition you can create a constructor with an `init` method as in the the previous example. \r\n\r\nYou can create an instance of the previous class like so: \r\n\r\n```javascript\r\ntm = TinyModel();\r\ntm.dance();\r\ntm.bump();\r\n```\r\nYou can also add instance methods using the prototype method as you normally would.\r\n\r\n```javascript\r\nvar TinyModel = J.extends(MiniModel);\r\n\r\nTinyModel.prototype.init = function() {\r\n\tconsole.log(\"Being created\")\r\n}\r\n\r\ntm = TinyModel();\r\n```\r\n\r\n### \"Static\" Methods\r\nYou can create static methods by capitalizing the name of the method you create. \r\n\r\n```javascript\r\nvar TinyModel = J.extends(MiniModel, {\r\n\tbump : function() {\r\n\t\tconsole.log(\"bumpping\")\r\n\t}, \r\n\r\n\tPlus : function(a,b) {\r\n\t\treturn a + b\r\n\t},\r\n\r\n\tinit : function() {\r\n\t\tconsole.log(\"initting Tiny Model\")\r\n\t}\r\n});\r\n\r\ntm = TinyModel();\r\nconsole.log(TinyModel.Plus(1,2));\r\n```\r\n### The Blueprint\r\nEverything in `J` extends from the `Blueprint` object.\r\n\r\n### Getting and Setting properties\r\nYou can initialize `Blueprint` with getters and setters. \r\n\r\n```javascript\r\nvar blueprint = J.Blueprint({\r\n\r\n});\r\n```\r\n\r\nThe `Blueprint` object/class gives everything that inherits it the ability to `get` and `set` properties. Those properties can then be watched for changes. \r\n\r\n```javascript\r\n//inherit from the Blueprint\r\nvar SomeModel = J.extends(J.Blueprint);\r\n\r\n//create a new Some Model\r\nvar sm = SomeModel();\r\n\r\n//Listen for changes to properties of some model\r\nsm.watcher = function(key,val) {\r\n\tconsole.log(\"sm change\",\"key:\",key, \"sm changed to:\",val)\r\n}\r\nconsole.log(sm.get(\"name\")); // undefined\r\nsm.set(\"name\",\"John\") // sm change key: name sm changed to: John\r\nconsole.log(sm.get(\"name\")); // John\r\nsm.set(\"name\",\"Frank\") // sm change key: name sm changed to: frank\r\nconsole.log(sm.get(\"name\")); // Frank\r\n```\r\n\r\nYou can create read only properties by creating a property starting with an underscore. This will create the properties sans underscore as a getter only. \r\n```javascript\r\nvar Blue = J.extends(J.Blueprint);\r\nvar blue = Blue({\r\n\tname : \"John\",\r\n\tage : 25,\r\n\t_i : 0\r\n});\r\n\r\nconsole.log(\r\n\tblue.get(\"name\"),\r\n\tblue.get(\"age\"),\r\n\tblue.get(\"i\"));\r\n// John 25 0\r\n\r\n\tblue.set(\"name\",\"Jeff\");\r\n\tblue.set(\"age\",30);\r\n\tblue.set(\"i\",20);\r\n\tblue.set(\"_winner\",false);\r\n\tblue.set(\"winner\",true);\r\n// Object {name: \"Jeff\", age: 30, i: 0, winner: false}\r\n\r\nconsole.log(\r\n\tblue.get(\"name\"),\r\n\tblue.get(\"age\"),\r\n\tblue.get(\"i\"),\r\n\tblue.get(\"winner\"));\r\n// Jeff 30 0 false\r\n```\r\n\r\n#### `_super`\r\nWhen you inherit from `Blueprint` you will have a `_super` method avaiable to you. You can use it to call the parent class method and override your own. Here is a basic implementation.\r\n```javascript\r\nvar container = document.getElementsByClassName(\"container\")[2];\r\nvar View = J.extends(J.View, {\r\n\trender: function(data) {\r\n\t\tthis._super(J.View,\"render\",[data]);\r\n\t}\r\n});\r\n```\r\n`this._super` takes the `SuperClass` as the first parameter. The name of the function as a string as the second parameter and the parameters you want to pass to said function as an array. In this example we are passing just one parameter to the super call. Then we can call `render` on our instance of our custom `View` class\r\n\r\n```javascript\r\nvar view = app.addView(\"list\",View({\r\n\tel: container,\r\n\ttemplate: \"sometemplate.html#item\"\r\n}));\r\n\r\nview.render({link:\"google.com\",\r\n\tname:{\r\n\t\tfirst:\"jeff\",\r\n\t\tmiddle: {\r\n\t\t\tinitial: \"B\",\r\n\t\t\tfull:\"Benjamin\"\r\n\t\t},\r\n\t\tlast:\"Johnston\",\r\n\t\tquote:\"and you know he was a good dog.\",\r\n\t\tnickname: \"Jacky\"\r\n\t}\r\n});\r\n```\r\nSee more on template rendering below.\r\n\r\n\r\n### The Mapper\r\nYou can use the `Mapper` class to get back a single instance of your model, or a new instance of your model. Make sure to create a single instance of a new `Mapper` with something like this: \r\n\r\n```javascript\r\nvar mapper = J.Mapper();\r\n```\r\n\r\nThen you add models to it with two methods `mapAModel` which will always return the same instance of a model. The mapper will instantiate it for you. You also have `mapModel` which will also instantiate a new model everytime you grab the model back. You can retrieve models with `getAModel` and `getModel`. \r\n\r\n```javascript\r\nvar mapper = J.Mapper();\r\nvar SomeModel = J.extends(J.Blueprint);\r\nmapper.mapAModel(\"some\",SomeModel);\r\nvar oneModel = mapper.getAModel(\"some\"); //give it a name. Mapping \"some\" model.\r\noneModel.set(\"name\",\"john\");\r\nconsole.log(oneModel.get(\"name\")); // returns John\r\nvar sameModel = mapper.getAModel(\"some\"); // get that same instance on a new variable. \r\nconsole.log(sameModel.get(\"name\")) // returns John. We are dealing with the same instance as before.\r\n```\r\n\r\n### Data Binding\r\nYou can setup to have data binding between different fields. Initialize a view with a `el` and setup your template and bindings. \r\n\r\n```javascript\r\nvar view = J.View(document.getElementById(\"content\"),{\r\n\tbind : {\r\n\t\t\"name\" : \"keyup #name-input\"\r\n\t}\r\n});\r\n```\r\nThis will bind the `name` property to the `keyup` of `#name-input`.\r\n\r\nIn your HTML you can setup an element to receive that data like so: \r\n\r\n```html\r\n<div data-j-bindable=\"name\"></div>\r\n<input type=\"text\" id=\"name-input\" />\r\n```\r\nUsing `data-j-bindable` means that anything that is populating a name property will appear in that div. \r\n\r\n### Templating Engine\r\nYou can create dynamic templates in HTML. You can use your own templating engine as well but to use the built in one just create a template file. For example `templates/hello.html`\r\n\r\n```html\r\n<!-- somefile.html -->\r\n*/list\\*\r\n<ul></ul>\r\n*\\list/*\r\n\r\n*/item\\*\r\n<li><a href=\"{link}\">\r\n\tA dog named {name.first} {name.middle.full|capitalize} {name.last|capitalize}\r\n\t<p>{name.quote|titleize}</p>\r\n\t<p>AKA: {name.nickname|camelCase}</p>\r\n</a></li>\r\n*\\item/*\r\n```\r\nYou can tell Just where to find your templates. \r\n\r\n```javascript\r\nJ.registerApp( J.App() );\r\nvar app = J.getApp();\r\napp.config = {\r\n\troot: \"http://localhost:3000\",\r\n\ttemplates: \"http://localhost:3000/templates\"\r\n};\r\n```\r\nWith this info in hand Just will make a url request for your templates, but only when you render. You tell Just which template on the page you want to grab. `*/templatename\\*` refers to the template name and wrap the end with `*\\templatename/*`. You can then grab the template like so\r\n```javascript\r\nvar container = document.getElementsByClassName(\"container\")[2];\r\nvar View = J.extends(J.View);\r\nvar view = app.addView(\"list\",View({\r\n\tel: container,\r\n\ttemplate: \"somefile.html#item\", //#item refers to the template name.\r\n}));\r\n```\r\nNotice that our view can grab variables. You can wrap the variable with a single curly brace to add a variable in there.\r\n\r\nWe also added a filter to our variable using the pipe `|`. There are a few included filters. You can add your own very easily. \r\n\r\n```javascript\r\nJ.addFilter(\"camelCase\",function(str){\r\n\treturn str.replace(/^([A-Z])|\\s(\\w)/g, function(match, p1, p2, offset) {\r\n\tif (p2) return p2.toUpperCase();\r\n\treturn p1.toLowerCase();        \r\n\t});\r\n});\r\n```\r\n\r\n### Views\r\nYou can create a view and link it to a main element. When rendering you can render in context of a child of that view or for the whole view. There is a couple of typical MVC issues with `Views` that we have solved. See `Mediators` below.\r\n\r\n```javascript\r\nvar view = J.View({\r\n\tel: document.getElementById(\"content\"),\r\n\ttemplate : J.html(\"<div>{{name}}</div>\");\r\n});\r\n```\r\n\r\n\r\n### Models\r\n`Blueprint` and `Model` are similar but `Model` is meant for being the M in MVC. You can set all of it's properties at creation time. You can do this for the model and when creating the model through the `Mapper`.\r\n\r\n```javascript\r\nvar mapper = J.Mapper();\r\nvar mainModel = mapper.mapAModel(\"mainModel\",J.Model,{\r\n\t\"height\" : 50\r\n});\r\nmainModel.set(\"name\",\"Jeffery\")\r\nmainModel.set(\"name2\",\"John\")\r\n\r\nvar otherModel = J.Model({\r\n\tcolor : \"#9b59b6\",\r\n\tsize : {\r\n\t\theight : 50,\r\n\t\twidth : 25\r\n\t}\r\n});\r\n```\r\nModels also have a `toJSON()` method and `toObject()` method. \r\n\r\n```javascript\r\nvar otherModel = J.Model({\r\n\tcolor : \"#9b59b6\",\r\n\tsize : {\r\n\t\theight : 50,\r\n\t\twidth : 25\r\n\t}\r\n});\r\nJ.l(otherModel.toObject());\r\nJ.l(otherModel.toJSON());\r\n```\r\nWe also have a convenience method you'll notice from the last example `J.l` which pipes directly to `console.log`. It's just easier to type. \r\n\r\n### Events\r\nWe have cross browser events available and you would (but won't have to see `App` below) create 1 event class/object for app wide event triggering and listening. \r\n\r\n```javascript\r\n// New instance of Events class.\r\nvar events = J.Events();\r\n\r\n// Subscribe\r\nevents.add(document.body,'customEvent',function() {\r\n\tconsole.log(\"Event triggered\")\r\n});\r\n// Trigger\r\nevents.trigger(document.body,'customEvent');\r\n```\r\n\r\n### App\r\nYou shouldn't need to create the `Event` on your own. It is included with your app object as well as other `App` nessesities. Here is a refactored version of the previous example using the App object for event delegation.\r\n\r\n```javascript\r\nvar App = J.App();\r\n\r\n// Subscribe\r\nApp.events.add(document.body,'customEvent',function() {\r\n\tconsole.log(\"Event triggered\")\r\n});\r\n// Trigger\r\nApp.events.trigger(document.body,'customEvent');\r\n```\r\nYou can set config values on your `App`.\r\n```javascript\r\nJ.registerApp( J.App() );\r\nvar app = J.getApp();\r\napp.config = {\r\n\troot: \"http://localhost:3000\",\r\n\ttemplates: \"http://localhost:3000/templates\"\r\n};\r\n```\r\n\r\n### Mediator\r\nThe Mediator (sometimes called the controller) is listening on behalf of the view and communicates with Models. The view in MVC is supposed to only be dealing with display information. If that's true then we don't do any logic *for* the view on the view. The problem in typical javascript MVC frameworks is that it is hard to tell the difference between the HTML view and the javascript view. Well in **Just**, we have solved that. You'll typically have one of two situations: \r\n\r\n1. You have your HTML written already and you just need to listen for events (buttons to be click, and text to be typed). \r\n2. You have an empty HTML element you want to populate with some data from the server. And it may change over time. \r\n\r\nIn the case of #1 you can use the `Mediator`. In that case your **View** is your HTML, since it alone is responsible for displaying data. The `Mediator` will listen to changes on your HTML view like it is supposed to do. \r\nIn the case of #2 you can use the `View` class and attach a `Mediator` to your view. You'll use template files to render your html. In that case your HTML is called templates and the responsibility of making things appear on the screen is left to your `View` class. \r\n\r\nAll that to say you can use your `Mediator` class in two ways. \r\n\r\n1. Where it acts with the view as the HTML. In that case you'll pass an HTML element to your `Mediator`. \r\n\r\n2. Where you have a view responsible for populating the template. In that case you'll pass a view class to the `Mediator`.\r\n\r\n### JQuery\r\nJQuery is not required. However if you happen to be using JQuery (if the JQuery object is available), Just will use it to support browsers.  **Bottom line:** Add JQuery if you want.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}